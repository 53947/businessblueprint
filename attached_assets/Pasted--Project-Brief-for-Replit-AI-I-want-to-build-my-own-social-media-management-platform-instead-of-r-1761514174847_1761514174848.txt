üß© Project Brief for Replit AI

I want to build my own social media management platform instead of relying on Synup or third-party tools.
This app will live inside BusinessBlueprint.io and will be accessed via the sub-path /post (e.g., https://businessblueprint.io/post).

The goal is to let small-business clients create, schedule, and publish posts to multiple social networks directly from my platform ‚Äî with analytics and AI-assisted content creation integrated.

üèóÔ∏è Core Concept

Platform Name: /post (Business Blueprint Post)

Parent Brand: BusinessBlueprint.io (part of the TriadBlue ecosystem)

Purpose: Replace Synup‚Äôs posting module with a native, brand-consistent, AI-powered social media dashboard.

‚öôÔ∏è Primary Features

Unified Post Composer

Create text, image, video, or carousel posts.

Integrate an AI caption generator and hashtag recommender (OpenAI API or local model).

Support dynamic variables like {business_name}, {city}, or {service} pulled from the user‚Äôs profile.

Multi-Network Scheduling

Connect to APIs for Facebook, Instagram, LinkedIn, X (Twitter), and Google Business Profile.

Schedule posts, auto-publish, or save as drafts.

Option to post immediately or bulk-schedule via CSV import.

Calendar & Queue View

Visual calendar for upcoming posts.

Drag-and-drop rescheduling.

Filter by platform, date, or campaign.

Media Library

Upload and manage brand assets (images, logos, short videos).

Include folders for campaign organization.

Basic editing (crop, overlay text, etc.)

Post Performance Analytics

Pull engagement data (likes, comments, clicks, reach).

Show per-platform stats and aggregate dashboard.

Display historical charts and ‚Äúbest posting times.‚Äù

AI Coach Integration

Offer suggestions for improving posts‚Äô reach and engagement.

Provide ‚Äúcontent score‚Äù (based on readability, hashtags, timing).

Option for users to ask the AI coach, ‚ÄúRewrite this post for better engagement.‚Äù

üñ•Ô∏è Technical Overview

Frontend: React + TypeScript (or Next.js) for UI/UX consistency with the BusinessBlueprint interface.

Backend: Node.js (Express) or Python (FastAPI) for API aggregation.

Database: PostgreSQL or Supabase for user data, post metadata, and analytics.

Integrations:

OAuth connections for each social network API

OpenAI (or compatible) for AI captioning

Cloud storage (S3 or Firebase) for media

Hosting: Same infrastructure as BusinessBlueprint.io

Access Control: User authentication shared with the main BusinessBlueprint login system.

üß† Optional Add-Ons (Phase 2)

‚ÄúSmart Repost‚Äù ‚Äî AI automatically recycles top-performing posts after X days.

Template library for branded post designs.

Shared workspace access for teams or agencies.

Would you like me to expand this into a Replit AI ‚Äúbuild instruction block‚Äù ‚Äî formatted for direct use (with file structure and starter code outline)? It would let you paste it straight into Replit and start generating the scaffolding.

You said:
yes please. what will you be telling it to do?
ChatGPT said:
Thought for 6s

Awesome ‚Äî here‚Äôs a copy-paste build instruction block you can drop into Replit AI. It tells it exactly what to scaffold and how the pieces fit together so you can launch BusinessBlueprint /post fast.

Build Instructions (for Replit AI)

Goal: Build a first-release, production-ready social media management app under BusinessBlueprint.io, mounted at /post. It replaces Synup‚Äôs posting module with a native, AI-assisted composer, scheduler, calendar, and analytics.

Name: BusinessBlueprint Post
Route: /post (e.g., https://businessblueprint.io/post)
Brand context: Part of the TriadBlue ecosystem (BusinessBlueprint.io).

1) Tech Stack & Key Decisions

Frontend: Next.js 14 (App Router) + TypeScript, Tailwind CSS

Auth: NextAuth (Credentials now; OAuth per network later), JWT sessions

Backend: Next.js API routes (Edge where possible), Node 20

DB/ORM: PostgreSQL + Prisma

Queue/Scheduler: BullMQ + Redis (for timed publishing)

AI: OpenAI (captioning, hashtags, tone rewrites)

Storage: S3-compatible (e.g., R2/S3/MinIO) for media

HTTP client: Axios

Date/time: Luxon

Validation: Zod

Charts: Recharts

State: React Query (TanStack Query)

Replit: create a Next.js + Node project and install dependencies listed below. Scaffold folders, files, and sample code as specified.

2) Create Files & Folders
/app
  /post
    page.tsx
    layout.tsx
    /composer
      page.tsx
    /calendar
      page.tsx
    /analytics
      page.tsx
    /api
      /auth/[...nextauth]/route.ts
      /posts/create/route.ts
      /posts/update/route.ts
      /posts/list/route.ts
      /posts/schedule/route.ts
      /media/upload/route.ts
      /providers/connect/route.ts
      /providers/callback/route.ts
      /analytics/summary/route.ts
/components
  Composer.tsx
  PlatformPicker.tsx
  MediaPicker.tsx
  HashtagSuggest.tsx
  CalendarGrid.tsx
  AnalyticsCards.tsx
  PostCard.tsx
  Loading.tsx
/lib
  db.ts
  auth.ts
  ai.ts
  storage.ts
  scheduler.ts
  providers/
    index.ts
    facebook.ts
    instagram.ts
    linkedin.ts
    x.ts
    googleBusiness.ts
  validations.ts
  analytics.ts
/prisma
  schema.prisma
/scripts
  seed.ts
/worker
  queue.ts
  jobs.ts
  publisher.ts
/styles
  globals.css
.env.example
README.md

3) Dependencies
npm i next@14 react react-dom next-auth @prisma/client prisma \
   zod axios luxon bullmq ioredis @tanstack/react-query recharts \
   formidable aws-sdk @aws-sdk/client-s3 mime
npm i -D typescript tailwindcss postcss autoprefixer prisma


Initialize Tailwind + Prisma:

npx tailwindcss init -p
npx prisma init

4) Environment Variables (.env)

Create .env from this template:

# NEXT/APP
NEXTAUTH_URL=https://businessblueprint.io
NEXTAUTH_SECRET=replace_with_strong_secret

# DB
DATABASE_URL=postgresql://user:pass@host:5432/bb_post

# REDIS
REDIS_URL=redis://default:pass@host:6379

# OPENAI
OPENAI_API_KEY=sk-...

# STORAGE (S3 compatible: R2/S3/MinIO)
S3_ENDPOINT=https://s3.amazonaws.com
S3_REGION=us-east-1
S3_BUCKET=bb-post-media
S3_ACCESS_KEY_ID=...
S3_SECRET_ACCESS_KEY=...

# OAUTH TOKENS PER NETWORK (set later per tenant/user)
FB_APP_ID=
FB_APP_SECRET=
IG_APP_ID=
IG_APP_SECRET=
LINKEDIN_CLIENT_ID=
LINKEDIN_CLIENT_SECRET=
X_CLIENT_ID=
X_CLIENT_SECRET=
GBP_CLIENT_ID=
GBP_CLIENT_SECRET=

5) Prisma Schema (prisma/schema.prisma)
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model User {
  id          String  @id @default(cuid())
  email       String  @unique
  name        String?
  image       String?
  role        Role    @default(USER)
  accounts    Account[]
  posts       Post[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  provider           Provider
  providerAccountId  String
  accessToken        String?
  refreshToken       String?
  expiresAt          DateTime?
  meta               Json?
  user               User    @relation(fields: [userId], references: [id])
  @@unique([provider, providerAccountId])
}

model Post {
  id            String   @id @default(cuid())
  userId        String
  content       String   // markdown/plain
  html          String?  // rendered
  mediaUrls     String[] @default([])
  platforms     Platform[] // e.g., [FACEBOOK, INSTAGRAM]
  scheduledFor  DateTime?
  status        PostStatus @default(DRAFT)
  results       Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

enum Role { USER ADMIN }
enum Provider { FACEBOOK INSTAGRAM LINKEDIN X GOOGLE_BUSINESS }
enum Platform { FACEBOOK INSTAGRAM LINKEDIN X GOOGLE_BUSINESS }
enum PostStatus { DRAFT QUEUED PUBLISHED FAILED }


Run:

npx prisma migrate dev --name init

6) Auth (lib/auth.ts + app/api/auth)

Use NextAuth with Credentials (email+magic link or simple password for now).

Add provider placeholders for social OAuth later.

// lib/auth.ts
import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
export const { handlers: { GET, POST }, auth } = NextAuth({
  providers: [
    Credentials({
      name: "Credentials",
      credentials: { email: {}, password: {} },
      async authorize(creds) {
        const user = await prisma.user.findUnique({ where: { email: creds?.email as string }});
        if (!user) return null;
        return { id: user.id, email: user.email, name: user.name, role: user.role };
      },
    }),
  ],
  session: { strategy: "jwt" },
  callbacks: {
    async jwt({ token }) { return token; },
    async session({ session, token }) { if (token?.sub) (session as any).userId = token.sub; return session; }
  },
  secret: process.env.NEXTAUTH_SECRET
});


Route:

// app/api/auth/[...nextauth]/route.ts
export { GET, POST } from "@/lib/auth";

7) Core Libraries

DB client

// lib/db.ts
import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();


AI helpers

// lib/ai.ts
import OpenAI from "openai";
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function suggestCaption(prompt: string) {
  const res = await client.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [{ role: "user", content: `Write a social caption: ${prompt}. Include relevant hashtags.` }],
    temperature: 0.7
  });
  return res.choices[0]?.message?.content ?? "";
}


Storage (S3)

// lib/storage.ts
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
const s3 = new S3Client({
  region: process.env.S3_REGION!,
  endpoint: process.env.S3_ENDPOINT,
  credentials: { accessKeyId: process.env.S3_ACCESS_KEY_ID!, secretAccessKey: process.env.S3_SECRET_ACCESS_KEY! }
});
export async function uploadBuffer(buf: Buffer, key: string, mime: string) {
  await s3.send(new PutObjectCommand({ Bucket: process.env.S3_BUCKET!, Key: key, Body: buf, ContentType: mime }));
  return `https://${process.env.S3_BUCKET!}.s3.${process.env.S3_REGION!}.amazonaws.com/${key}`;
}


Scheduler/Queue

// lib/scheduler.ts
import { Queue } from "bullmq";
import IORedis from "ioredis";
export const connection = new IORedis(process.env.REDIS_URL!);
export const publishQueue = new Queue("publish", { connection });

8) Provider Abstraction (lib/providers/*.ts)

Create a uniform interface:

// lib/providers/index.ts
export type PublishPayload = { content: string; mediaUrls: string[]; when?: Date };
export type PublishResult = { provider: string; postId?: string; error?: string };

export interface ProviderAdapter {
  name: string;
  connect(authCode: string): Promise<void>;
  publish(payload: PublishPayload, accountId: string): Promise<PublishResult>;
}

export * as facebook from "./facebook";
export * as instagram from "./instagram";
export * as linkedin from "./linkedin";
export * as x from "./x";
export * as googleBusiness from "./googleBusiness";


Stub each adapter with a TODO where API calls will be placed. Example:

// lib/providers/facebook.ts
import { ProviderAdapter, PublishPayload, PublishResult } from ".";
export const adapter: ProviderAdapter = {
  name: "FACEBOOK",
  async connect(_code: string) { /* exchange code for tokens (TODO) */ },
  async publish(payload: PublishPayload, accountId: string): Promise<PublishResult> {
    // TODO: call Facebook Graph API with account token
    console.log("FB publish", { accountId, ...payload });
    return { provider: "FACEBOOK", postId: "mock_fb_post_123" };
  }
};


Repeat for instagram/linkedin/x/googleBusiness with console stubs.

9) API Routes
Create Post
// app/api/posts/create/route.ts
import { prisma } from "@/lib/db";
import { auth } from "@/lib/auth";
import { z } from "zod";

const schema = z.object({
  content: z.string().min(1),
  mediaUrls: z.array(z.string().url()).default([]),
  platforms: z.array(z.enum(["FACEBOOK","INSTAGRAM","LINKEDIN","X","GOOGLE_BUSINESS"])).min(1),
});

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user) return new Response("Unauthorized", { status: 401 });
  const body = await req.json();
  const data = schema.parse(body);
  const post = await prisma.post.create({
    data: { userId: (session as any).userId, content: data.content, mediaUrls: data.mediaUrls, platforms: data.platforms }
  });
  return Response.json(post);
}

Schedule Post
// app/api/posts/schedule/route.ts
import { prisma } from "@/lib/db";
import { publishQueue } from "@/lib/scheduler";
import { DateTime } from "luxon";
import { auth } from "@/lib/auth";
import { z } from "zod";

const schema = z.object({ postId: z.string(), scheduledFor: z.string() /* ISO */ });

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user) return new Response("Unauthorized", { status: 401 });
  const { postId, scheduledFor } = schema.parse(await req.json());
  const iso = DateTime.fromISO(scheduledFor).toUTC();
  await prisma.post.update({ where: { id: postId }, data: { scheduledFor: iso.toJSDate(), status: "QUEUED" }});
  await publishQueue.add("publish", { postId }, { delay: Math.max(0, iso.diff(DateTime.utc()).as("milliseconds")) });
  return Response.json({ ok: true });
}

List Posts
// app/api/posts/list/route.ts
import { prisma } from "@/lib/db";
import { auth } from "@/lib/auth";

export async function GET() {
  const session = await auth();
  if (!session?.user) return new Response("Unauthorized", { status: 401 });
  const posts = await prisma.post.findMany({ where: { userId: (session as any).userId }, orderBy: { createdAt: "desc" }});
  return Response.json(posts);
}

Media Upload (multipart)
// app/api/media/upload/route.ts
import { NextRequest } from "next/server";
import { uploadBuffer } from "@/lib/storage";
import { auth } from "@/lib/auth";
import { randomUUID } from "crypto";
import { Readable } from "stream";

export async function POST(req: NextRequest) {
  const session = await auth();
  if (!session?.user) return new Response("Unauthorized", { status: 401 });

  const form = await req.formData();
  const file = form.get("file") as unknown as File;
  const arrayBuf = await file.arrayBuffer();
  const buf = Buffer.from(arrayBuf);
  const key = `media/${(session as any).userId}/${randomUUID()}-${file.name}`;
  const url = await uploadBuffer(buf, key, file.type);
  return Response.json({ url });
}

Analytics Summary (stub)
// app/api/analytics/summary/route.ts
export async function GET() {
  // TODO: fetch provider insights and aggregate
  return Response.json({ postsLast30Days: 12, avgEngagement: 2.4, bestDay: "Thursday" });
}

10) Worker (BullMQ) ‚Äî Publishing Jobs
// worker/queue.ts
import { Worker } from "bullmq";
import { connection } from "@/lib/scheduler";
import { handlePublishJob } from "./publisher";

new Worker("publish", async (job) => handlePublishJob(job.data), { connection });

// worker/publisher.ts
import { prisma } from "@/lib/db";
import * as providers from "@/lib/providers";
export async function handlePublishJob({ postId }: { postId: string }) {
  const post = await prisma.post.findUnique({ where: { id: postId }});
  if (!post) return;
  const adapters = {
    FACEBOOK: providers.facebook.adapter,
    INSTAGRAM: providers.instagram.adapter,
    LINKEDIN: providers.linkedin.adapter,
    X: providers.x.adapter,
    GOOGLE_BUSINESS: providers.googleBusiness.adapter,
  } as const;

  const results = [];
  for (const p of post.platforms) {
    try {
      const r = await adapters[p].publish({ content: post.content, mediaUrls: post.mediaUrls }, "ACCOUNT_ID_TODO");
      results.push(r);
    } catch (e:any) { results.push({ provider: p, error: e?.message || "publish error" }); }
  }
  await prisma.post.update({ where: { id: postId }, data: { status: "PUBLISHED", results }});
}


Replit: run the worker in a separate process (Procfile or npm run worker) using tsx or ts-node.

11) UI Pages & Components

/post: dashboard cards (Quick Composer, Queue, Last 5 posts, Analytics summary).

/post/composer: main composer (textarea + media upload + PlatformPicker + AI helpers).

/post/calendar: drag/drop schedule (CalendarGrid).

/post/analytics: summary charts (AnalyticsCards).

Skeleton example:

// app/post/page.tsx
export default function PostHome() {
  return (
    <main className="p-6 space-y-6">
      <h1 className="text-2xl font-semibold">BusinessBlueprint /post</h1>
      {/* Quick Composer, Upcoming Queue, Recent Posts, Analytics Summary */}
    </main>
  );
}

// components/Composer.tsx (core bits)
"use client";
import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import axios from "axios";

export default function Composer() {
  const [content, setContent] = useState("");
  const [platforms, setPlatforms] = useState<string[]>([]);
  const [mediaUrls, setMediaUrls] = useState<string[]>([]);

  const create = useMutation({
    mutationFn: async () => (await axios.post("/post/api/posts/create", { content, platforms, mediaUrls })).data
  });

  return (
    <div className="space-y-3">
      <textarea className="w-full border rounded p-3" rows={6} placeholder="Write your post..." value={content} onChange={e=>setContent(e.target.value)} />
      {/* MediaPicker, PlatformPicker, HashtagSuggest */}
      <button className="px-4 py-2 rounded bg-blue-600 text-white" onClick={()=>create.mutate()}>Save Draft</button>
    </div>
  );
}

12) Seed Script
// scripts/seed.ts
import { prisma } from "@/lib/db";
async function main() {
  await prisma.user.upsert({
    where: { email: "admin@businessblueprint.io" },
    update: {},
    create: { email: "admin@businessblueprint.io", name: "Admin", role: "ADMIN" }
  });
}
main().catch(e=>{console.error(e);process.exit(1)}).finally(()=>process.exit(0));


Run:

ts-node scripts/seed.ts

13) Commands & Scripts (package.json)

Add:

{
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "worker": "node --loader tsx ./worker/queue.ts",
    "migrate": "prisma migrate deploy",
    "seed": "tsx ./scripts/seed.ts"
  }
}

14) Acceptance Criteria (MVP)

Login works; a seed admin exists.

Compose/save a draft post with media.

AI can suggest a caption/hashtags for given text.

Select platforms and schedule a post.

Job runs at scheduled time (BullMQ) and calls provider stubs.

Calendar view shows queued/past posts.

Analytics page displays mock summary.

All secrets via .env. No crashes in dev.

15) Next Steps / Phase 2

Implement real provider OAuth + token refresh.

Real analytics ingestion (per platform) + charts.

Team workspaces (multi-user per business).

Content templates and brand libraries.

‚ÄúSmart Repost‚Äù automation and best-time recommendations.

Replit AI: Please scaffold exactly as above, create all files with the provided content/stubs, wire up the routes, and ensure npm run dev and npm run worker both run without errors.

You said:
how are you able to do this without even knowing how the rest of the site is set up?  what plastforms 'm using that could and have caused conflict.  or overriden each other.  this project is 6 months in the making.  
ChatGPT said:
Thought for 10s

Totally fair question. Short answer: I proposed a self-contained scaffold that can run in isolation, so we don‚Äôt trample anything you already built. Long answer below‚Äîhow I made assumptions, where conflicts could happen, and how to integrate safely without breaking your 6-month stack.

Why I can design this now

I picked defaults that are:

Portable (can live as its own service).

Namespaced (all code, CSS, API routes, DB tables scoped to the /post feature).

Swappable (you can replace Next.js/Prisma/Redis pieces with your stack).

You can either:

Embed it inside your existing app if you‚Äôre already on React/Next, or

Run it as a separate mini-service and mount it behind a reverse proxy at /post so it won‚Äôt clash with anything.

Where conflicts usually happen (and how to avoid them)
1) Routing & app framework

Conflict: Your site may already use a router (Next pages vs. Next app-router, Remix, Nuxt, WordPress, PHP, Rails, etc.).

Fix:

Reverse proxy /post to a separate service (Nginx/Cloudflare/Vercel functions).

Or mount under a sub-app (e.g., Next.js app dir at /post only).

Avoid global middlewares that rewrite /post/*.

2) Package ecosystem & Node versions

Conflict: Mixed package managers (npm/yarn/pnpm), Node 16 vs 18/20, ESM/CJS imports.

Fix: Lock versions with .nvmrc/engines and a single package manager. Keep /post in its own workspace or repo to isolate deps.

3) CSS/Tailwind & global styles

Conflict: Tailwind preflight and global resets change typography/buttons site-wide; CSS class collisions; component library styles leaking.

Fix:

Run /post as a separate app (cleanest).

Or scope CSS: turn off Tailwind preflight for legacy pages; use CSS Modules within /post; prefix classes (e.g., .bbp-); isolate with a wrapper div #bbp-root and descendant selectors only.

4) Auth & sessions

Conflict: Two auth systems competing for cookies or session domains; CSRF token mismatch; NextAuth vs custom JWT.

Fix:

Share the same auth cookie domain if you want SSO, or keep /post separate login.

Namespaced cookies (bbp_session), and set distinct callback URLs.

If you already use Auth0/Cognito, swap NextAuth for your provider.

5) Database & migrations

Conflict: Prisma migrations colliding with existing tables/schemas; different DB engines (MySQL vs Postgres).

Fix:

Use a separate database (safest), or

Use a separate schema namespace in Postgres (e.g., @@schema("post")) so tables = post.User, post.Post.

If you‚Äôre on MySQL, adjust Prisma datasource accordingly.

6) Job scheduling / queues

Conflict: Redis/BullMQ version or you already have a scheduler (Sidekiq, Celery, Bee, Cloud Tasks).

Fix: Adapter layer‚Äîkeep a publisher abstraction; swap BullMQ for your queue of choice with the same interface.

7) API namespaces & CORS

Conflict: /api/* routes already used; CORS blocking cross-origin requests if /post runs elsewhere.

Fix: Put endpoints under /post/api/*, and set CORS to allow your main origin. Reverse proxy keeps it same-origin = no CORS.

8) Build/hosting

Conflict: Existing hosting expects static exports; edge runtime differences; Cloudflare vs Vercel vs Netlify conventions.

Fix: Keep /post as an independent deployable; proxy it under the main domain. Choose the same platform you already use, or keep it containerized.

9) TypeScript & path aliases

Conflict: Different tsconfig paths and strictness; module resolution clashes.

Fix: Local tsconfig.json inside /post; no global aliases; or prefix aliases with @bbp/*.

Safe integration plans (pick one)
Plan A ‚Äî Zero-risk isolation (recommended)

Deploy /post as a separate service (its own repo or workspace).

Add a reverse proxy rule: https://businessblueprint.io/post -> https://post-service.internal

Benefits: No CSS/router/dep conflicts. You can ship fast, then integrate SSO later.

Plan B ‚Äî Same repo, isolated workspace

Monorepo with apps/marketing (your current site) and apps/post.

Independent package.json, lockfiles, envs.

Dev proxy: the marketing app proxies /post to the post app locally.

CI/CD deploys both.

Plan C ‚Äî Fully embedded module (if your site is Next.js)

Keep the folder structure I proposed only under /app/post.

Scope CSS as above; rename cookies; scope APIs to /post/api.

Verify Node/Next versions match; run a staging path /post-staging first.

15-minute Compatibility Audit (fill once; no back-and-forth needed)

Framework: What is the main site built on? (WordPress/PHP, Next.js, plain React, Laravel, Rails, etc.)

Hosting: Vercel, Cloudflare Pages/Workers, Netlify, cPanel/VPS, Docker/K8s?

Auth now: Custom JWT, Auth0, Clerk, Cognito, NextAuth, WordPress login?

DB now: Postgres/MySQL/Serverless (PlanetScale/Supabase/RDS)/none?

Queue now: None / Redis / SQS / Cloud Tasks / Sidekiq?

CSS setup: Tailwind? Bootstrap? Global resets? Component libraries?

Package manager & Node: npm/yarn/pnpm + Node version.

Preferred integration: Plan A (proxy), B (monorepo), or C (embed).

Environments: Need staging at /post-staging before live?

Domains: Keep path /post, or OK with subdomain post.businessblueprint.io (simpler tech, same UX via nav)?