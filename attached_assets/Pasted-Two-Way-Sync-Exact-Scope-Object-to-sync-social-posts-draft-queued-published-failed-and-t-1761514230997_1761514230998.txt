Two-Way Sync (Exact Scope)

Object to sync: social posts (draft → queued → published → failed) and their metadata.
Direction:

Outbound (/post → Synup): create/update post records so Synup staff can execute/support.

Inbound (Synup → /post): receive status changes or notes so your dashboard stays current.

1) Where to put the code (folders & files)
/lib/sync/
  events.ts            // tiny event helpers (emitSyncEvent)
  mapper.ts            // map internal <-> synup payloads
  policy.ts            // conflict rules (which side wins per field)
/lib/integrations/
  synup.ts             // Synup client: auth, POST/PUT helpers

/worker/
  jobs.ts              // add: queueSynupPush, queueSynupPull
  publisher.ts         // call queueSynupPush after publish/save
  consumers.synup.ts   // worker handlers for outbound/inbound jobs

/app/post/api/sync/synup/
  push/route.ts        // manual trigger (admin) to push a post
  webhook/route.ts     // Synup -> your webhook receiver


If you’re running /post as a separate service, paths are identical. If embedded, keep these exact subpaths to avoid collisions.

2) Minimal DB additions (Prisma)

Add to prisma/schema.prisma:

model ExternalSystem {
  id        String  @id @default(cuid())
  name      String  @unique // "synup"
  createdAt DateTime @default(now())
}

model ExternalSync {
  id            String   @id @default(cuid())
  systemId      String
  entityType    String   // "post"
  entityId      String   // local Post.id
  externalId    String?  // Synup's object id
  lastPushedAt  DateTime?
  lastPulledAt  DateTime?
  checksum      String?  // to avoid redundant pushes
  status        String   @default("idle") // idle|pending|error
  meta          Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  system        ExternalSystem @relation(fields: [systemId], references: [id])
}

model SyncLog {
  id        String   @id @default(cuid())
  system    String   // "synup"
  direction String   // "outbound" | "inbound"
  entity    String   // "post"
  entityId  String
  payload   Json
  status    String   // ok|error
  message   String?
  createdAt DateTime @default(now())
}


Run: npx prisma migrate dev --name sync_tables

3) Environment variables

Add to .env:

SYNUP_BASE_URL=https://api.synup.com
SYNUP_API_KEY=...
SYNUP_WEBHOOK_SECRET=...

4) Outbound flow (your app → Synup)

When it triggers: on create draft, update, and publish in your existing post flow.

In app/api/posts/create/route.ts and .../update/route.ts after DB write:

import { emitSyncEvent } from "@/lib/sync/events";
await emitSyncEvent({ system: "synup", direction: "outbound", entity: "post", entityId: post.id, action: "UPSERT" });


In worker/consumers.synup.ts handle the job:

// Pseudocode
const post = await prisma.post.findUnique({ where: { id: entityId }});
const sync = await prisma.externalSync.upsert(...); // ensure row exists

const payload = mapPostToSynup(post); // /lib/sync/mapper.ts
const res = await synup.upsertPost(payload); // /lib/integrations/synup.ts

await prisma.externalSync.update({
  where: { id: sync.id },
  data: { externalId: res.id, lastPushedAt: new Date(), checksum: hash(payload), status: "idle" }
});
await prisma.syncLog.create({ data: { system:"synup", direction:"outbound", entity:"post", entityId: post.id, payload, status:"ok" }});


Mapper (example fields only):

// /lib/sync/mapper.ts
export function mapPostToSynup(post: Post) {
  return {
    title: (post.content || "").slice(0, 80),
    body: post.content,
    media: post.mediaUrls,
    platforms: post.platforms, // map enum names if Synup differs
    status: post.status,       // transform to Synup’s status set if needed
    scheduled_at: post.scheduledFor?.toISOString() ?? null,
    local_id: post.id          // keep backlink
  };
}

5) Inbound flow (Synup → your app)

Create a webhook endpoint:

// /app/post/api/sync/synup/webhook/route.ts
import { NextRequest } from "next/server";
import { applySynupUpdate } from "@/lib/sync/policy";

export async function POST(req: NextRequest) {
  const sig = req.headers.get("x-synup-signature");
  // verify sig with SYNUP_WEBHOOK_SECRET (HMAC)
  const body = await req.json();

  // body should include external_id or local_id, new status/notes, etc.
  await applySynupUpdate(body); // see below
  return new Response("ok", { status: 200 });
}


Conflict policy (one file, predictable):

// /lib/sync/policy.ts
// Rule of thumb to avoid surprises:
// - Status: the side that has a terminal state ("PUBLISHED" or "FAILED") wins.
// - Scheduled time: if local is QUEUED and Synup modifies time, accept Synup.
// - Content: local is source of truth after publish; before publish, last-write-wins with timestamp guard.

export async function applySynupUpdate(payload: any) {
  // 1) resolve local post by payload.local_id or by ExternalSync.externalId
  // 2) compare fields; apply rules above
  // 3) write to Post and ExternalSync.lastPulledAt; append SyncLog
}


Keep the policy simple and documented so support actions from Synup do not override your final published content.

6) Manual push endpoint (optional, for support/admin)
// /app/post/api/sync/synup/push/route.ts
import { emitSyncEvent } from "@/lib/sync/events";
export async function POST(req: Request) {
  const { postId } = await req.json();
  await emitSyncEvent({ system:"synup", direction:"outbound", entity:"post", entityId: postId, action:"UPSERT" });
  return Response.json({ ok: true });
}

7) Event helper & jobs
// /lib/sync/events.ts
import { publishQueue } from "@/lib/scheduler";
export async function emitSyncEvent(evt:{system:"synup",direction:"outbound"|"inbound",entity:"post",entityId:string,action:string}) {
  await publishQueue.add("sync.synup", evt);
}


In your worker:

// /worker/jobs.ts (register handler)
worker.on("completed", ...);
worker.on("failed", ...);

// add handler for "sync.synup" that calls consumers.synup.ts

8) Dashboard surface (no new UI, just badges)

In your existing Posts list and Post detail:

show a tiny Synced ✓ badge if ExternalSync.externalId exists.

show Last pushed/pulled timestamps and last status.

add a small “Push to Synup” button that calls /post/api/sync/synup/push.

This reuses your current dashboard; no extra pages.

9) Testing checklist (1 hour)

Create a draft → verify ExternalSync row created.

Update content → outbound job runs → SyncLog outbound ok.

Hit webhook with a sample payload → content/status updates per policy → SyncLog inbound ok.

Publish a post → outbound updates external status → badge shows synced.

Summary

You get a contained two-way sync: one client file (/lib/integrations/synup.ts), one mapper, one policy, two API routes (push + webhook), and three tiny tables.

It plugs into your existing dashboard (just a badge and optional “push” button).

No new surfaces, no wider architecture changes, no ambiguity about where anything lives.